# 解耦模式

## 项目说明

Game模式下，点击鼠标可以设置多个目标点，Player（方块）会依次移向目标点

> 解耦模式中包含了三种不同的模式，这里只实现了事件序列作为参考，其他两种模式在Unity中均有较好实现，可参考笔记内容

### EventQueue

监听鼠标点击事件，在鼠标点击时向队列注入新的目标点；Update中，若当前目标点为空，则取出队列第一位作为当前目标点，若到达当前目标点，则删除

## [笔记](https://gpp.tkchu.me/decoupling-patterns.html)

### 是什么、为什么（个人理解）

包含了

- 组件模式
  - 本质上是功能的模块化，延伸了面向对象的解耦思想
  - U3D的编程思想就是面向组件的，MonoBehaviour的子类都可作为组件挂在GameObject上
- 事件序列
  - 就像银行办事需要排号一样——每个顾客要处理的事都是一个事件，编号后就形成了天然的事件序列，银行会按一定规则来依次处理队列中的事件
  - 一般在底层实现，但宏观上依然存在，例如RTS游戏中通过Shift对一些单位下达前往不同位置的命令
  - Unity中协程可以用来做消息队列，防止同帧产生大量的计算
- 服务定位器
  - 类似单例模式，在运行时寻找组件（而不是运行前赋值）
  - Unity中GetComponent，FindObjectOfType，Find等方法都可帮助实现相关服务的查找，但此类反射方法要避免在运行时高频循环调用
  - 拓展——还可以建立一个运行前赋值的服务注册中心（当然也可运行中赋值），其他需要服务的对象在运行时去注册中心查找相关服务，这样做一方面可以避免全局反射的恶果，一方面可以保留服务定位器带来的解耦优势——单例模式也可使用这样的方法来替换（对象注册中心）

### 怎么做（事件队列）

点击鼠标时在Queue中添加一个红点，当目标点为空时从Queue中取出第一位位作为目标点，让Player移向目标点，到达目标点时删除目标点

#### 具体实现：

https://github.com/TYJia/GameDesignPattern_U3D_Version/tree/master/Assets/009DecouplingPatterns